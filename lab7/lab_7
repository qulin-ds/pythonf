import functools
import sys
import io
import logging
import math
import requests


def logger(func=None, *, handle=sys.stdout):
    """
    Параметризуемый декоратор логирования.

    - Если handle — logging.Logger, логируем через .info() / .error().
    - Иначе считаем, что у handle есть .write() и пишем туда строки.
    """

    def decorator(f):

        is_logging_logger = isinstance(handle, logging.Logger)

        @functools.wraps(f)
        def wrapper(*args, **kwargs):
            # Определяем функции log_info / log_error в зависимости от handle
            if is_logging_logger:
                log_info = handle.info
                log_error = handle.error
            else:
                def log_info(msg: str):
                    handle.write(f"INFO: {msg}\n")

                def log_error(msg: str):
                    handle.write(f"ERROR: {msg}\n")

            # Логируем старт вызова
            log_info(f"Calling {f.__name__} with args={args}, kwargs={kwargs}")

            try:
                result = f(*args, **kwargs)
                # Логируем успешное завершение
                log_info(f"{f.__name__} returned {result!r}")
                return result
            except Exception as e:
                # Логируем ошибку и пробрасываем дальше
                log_error(f"{f.__name__} raised {type(e).__name__}: {e}")
                raise

        return wrapper

    # Поддержка вызова как @logger и как @logger(...)
    if func is None:
        return decorator
    else:
        return decorator(func)


@logger(handle=sys.stdout)
def get_currencies(
    currency_codes: list,
    url: str = "https://www.cbr-xml-daily.ru/daily_json.js",
) -> dict:
    """
    Получает курсы валют с API ЦБ РФ.

    Возвращает словарь вида {"USD": 93.25, "EUR": 101.7}.

    Исключения:
    - ConnectionError: API недоступен (ошибки сети / HTTP).
    - ValueError: некорректный JSON.
    - KeyError: нет ключа "Valute" или нужной валюты.
    - TypeError: курс валюты имеет неверный тип.
    """
    # API недоступен
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"API is not available: {e}")

    # Некорректный JSON
    try:
        data = response.json()
    except ValueError as e:
        raise ValueError(f"Invalid JSON: {e}")

    # Нет ключа "Valute"
    if "Valute" not in data:
        raise KeyError("Key 'Valute' not found in response")

    valute = data["Valute"]
    result = {}

    for code in currency_codes:
        # Валюта отсутствует в данных
        if code not in valute:
            raise KeyError(f"Currency {code} not found in data")

        # Курс валюты имеет неверный тип
        value = valute[code].get("Value")
        if not isinstance(value, (int, float)):
            raise TypeError(f"Rate for {code} has invalid type: {type(value)}")

        result[code] = float(value)

    return result


# ---------- Файловый логгер для курсов валют ----------

file_logger = logging.getLogger("currency_file")
file_logger.setLevel(logging.INFO)

file_handler = logging.FileHandler("currency.log", encoding="utf-8")
file_formatter = logging.Formatter(
    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
file_handler.setFormatter(file_formatter)
file_logger.addHandler(file_handler)
file_logger.propagate = False


@logger(handle=file_logger)
def get_currencies_file(
    currency_codes: list,
    url: str = "https://www.cbr-xml-daily.ru/daily_json.js",
) -> dict:
    """
    Та же бизнес-логика get_currencies, но логирование в файл.
    Используем __wrapped__, чтобы обратиться к оригинальной функции без декоратора.
    """
    return get_currencies.__wrapped__(currency_codes, url=url)


# ---------- Демонстрационный пример: квадратное уравнение ----------

quad_logger = logging.getLogger("quadratic")
quad_logger.setLevel(logging.INFO)

quad_handler = logging.StreamHandler(sys.stdout)
quad_handler.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))
quad_logger.addHandler(quad_handler)


@logger(handle=quad_logger)
def solve_quadratic(a, b, c):
    """
    Решение квадратного уравнения a*x^2 + b*x + c = 0.

    Демонстрация уровней:
    - INFO: старт/успешное завершение (делает декоратор).
    - WARNING: дискриминант < 0.
    - ERROR: некорректные данные (a = "abc" и т.п.).
    - CRITICAL: a = 0 и b = 0 (нет уравнения).
    """

    # CRITICAL-ситуация: не уравнение
    if a == 0 and b == 0:
        quad_logger.critical("Both a and b are zero; not an equation")
        raise ValueError("Both a and b are zero")

    # Ошибка типов/значений
    try:
        a = float(a)
        b = float(b)
        c = float(c)
    except (TypeError, ValueError) as e:
        quad_logger.error(f"Invalid coefficients: {e}")
        raise

    d = b * b - 4 * a * c

    if d < 0:
        quad_logger.warning(f"Negative discriminant: {d}")
        return None  # корней нет

    if d == 0:
        x = -b / (2 * a)
        return (x,)

    sqrt_d = math.sqrt(d)
    x1 = (-b - sqrt_d) / (2 * a)
    x2 = (-b + sqrt_d) / (2 * a)
    return x1, x2


if __name__ == "__main__":
    # Примеры работы get_currencies с логированием в stdout
    try:
        print("Курсы валют (stdout):", get_currencies(["USD", "EUR"]))
    except Exception as e:
        print("Ошибка при получении курсов (stdout):", e)

    # Примеры работы get_currencies_file с логированием в файл
    try:
        print("Курсы валют (file):", get_currencies_file(["USD", "EUR"]))
        print("Логи записаны в файл currency.log")
    except Exception as e:
        print("Ошибка при получении курсов (file):", e)

    # Примеры для квадратного уравнения
    print("Два корня:", solve_quadratic(1, -3, 2))          # два корня
    print("Отрицательный дискриминант:", solve_quadratic(1, 0, 1))  # WARNING

    try:
        solve_quadratic("abc", 2, 1)  # ERROR
    except Exception:
        pass

    try:
        solve_quadratic(0, 0, 1)  # CRITICAL
    except Exception:
        pass
